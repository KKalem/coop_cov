#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
# Ozer Ozkahraman (ozero@kth.se)

import numpy as np
import dubins

from toolbox import geometry as geom
from auv import AUV
from mission_plan import TimedWaypoint, MissionPlan


class Agent(object):
    COLORS = ['red', 'blue', 'green', 'purple', 'orange', 'cyan']
    def __init__(self,
                 real_auv,
                 pose_graph,
                 mission_plan,
                 drift_model = None):

        # a reference to the actual physical auv
        # for ceonvenience
        self._real_auv = real_auv


        self.pg = pose_graph
        self.mission_plan = mission_plan
        self.drift_model = drift_model

        # this auv model will be used to create the pose graph from
        # noisy measurements of the real auv
        self.internal_auv = AUV(auv_id = real_auv.auv_id,
                                init_pos = real_auv.pose[:2],
                                init_heading = real_auv.pose[2],
                                target_threshold = real_auv.target_threshold,
                                forward_speed = real_auv.forward_speed,
                                auv_length = real_auv.auv_length,
                                max_turn_angle = real_auv.max_turn_angle)

        self.id = real_auv.auv_id

        # keep track of time passed for waiting purposes
        self.time = 0

        # to keep track of when we were connected to another auv
        # so that we can optimize the PG when we disconnect
        self.connection_trace = []

        # keep a record of how many vertices and edges we received through "fill_in_since_last_interaction"
        # clock, num list
        self.received_data = {'verts':[(0.,0.)],
                              'edges':[(0.,0.)]}

        # list of distances between real auv and internal auv
        self.real_errors = []

        # for each waypoint in the missionplan, we might have many pts in between
        # generated by a dubins path planner
        # we need to give these one by one to the auv
        # and re-calculate the path plan when we reach a mission wp
        self.current_dubins_points = []

        # some visualization data
        self.viz_plan_points = []
        self.viz_optim_points = []
        self.viz_waited_points = []
        self.color = Agent.COLORS[self.id%len(Agent.COLORS)]



    def log(self, *args):
        if len(args) == 1:
            args = args[0]
        print(f'[AGNT:{self.pg.pg_id}]\t{args}')


    def update(self, dt, all_agents):
        # update internal auv
        # apply the same control to real auv, with enviromental noise
        # measure real auv (heading?), apply onto internal auv
        # update pose graph with internal auv

        self.time += dt


        ### MISSION SYNC
        at_target = False
        current_timed_wp = self.mission_plan.get_current_wp(self.id)
        if current_timed_wp is None:
            self.mission_plan.visit_current_wp(self.id)
            current_timed_wp = self.mission_plan.get_current_wp(self.id)
            dist = geom.euclid_distance(self.internal_auv.pose[:2], current_timed_wp.pose[:2])
        else:
            dist = geom.euclid_distance(self.internal_auv.pose[:2], current_timed_wp.pose[:2])
            at_target = dist <= self.internal_auv.target_threshold
            if at_target:
                if self.time >= current_timed_wp.time:
                    # we have reached the point, and we dont need to wait here
                    # get the next wp
                    self.mission_plan.visit_current_wp(self.id)
                    current_timed_wp = self.mission_plan.get_current_wp(self.id)
                    self.current_dubins_points = []
                else:
                    self.viz_waited_points.append(self.internal_auv.pose)

        if current_timed_wp is None:
            # this agent is 'done'
            # do nothing
            return

        ### PATH PLANNING
        # if the point is far away enough, use dubins. If it is close by, just use
        # simple heading controller of the AUV itself
        if dist < self.internal_auv.target_threshold + 0.5:
            target_posi = current_timed_wp.pose[:2]
        else:
            # first check if we already have a dubins path planned for this WP
            if self.current_dubins_points is None or len(self.current_dubins_points)==0:
                # there is no path planned for this WP, plan it now
                dubins_path = dubins.shortest_path(self.internal_auv.pose,
                                                   current_timed_wp.pose,
                                                   self.mission_plan.config['turning_rad'])
                # sample it and set the path
                pts, times = dubins_path.sample_many(0.5)
                self.current_dubins_points = pts
                self.viz_plan_points.append(self.internal_auv.pose)

            # we have a path to follow
            # skip the points that are too close 
            target_posi = self.current_dubins_points[0][:2]
            while geom.euclid_distance(self.internal_auv.pose[:2], self.current_dubins_points[0][:2]) <= self.internal_auv.target_threshold:
                if len(self.current_dubins_points) > 1:
                    self.current_dubins_points = self.current_dubins_points[1:]
                    # then set the first point of the plan as the auvs target
                    target_posi = self.current_dubins_points[0][:2]
                else:
                    break



        ### MOTION
        # if this is a 'first' waypoint, stop covering
        # if its a 'last', start covering
        cover = current_timed_wp.position_in_line == TimedWaypoint.LAST

        # if we are alone, we will drift
        alone = True
        for agent in all_agents:
            # skip self
            if agent.pg.pg_id == self.pg.pg_id:
                continue
            dist = geom.euclid_distance(self._real_auv.pose[:2], agent._real_auv.pose[:2])
            if dist <= self.mission_plan.config['comm_range']:
                alone = False
                break

        self.internal_auv.set_target(target_posi, cover=cover)
        # control real auv with what the internal one thinks
        # without any drifting knowledge
        td, ta = self.internal_auv.update(dt)

        # if we are doing coverage work, then we also drift
        if cover and alone and self.drift_model is not None:
            _,_, drift_trans_angle = drift_model.sample(self._real_auv.pos[0],
                                                        self._real_auv.pose[1])
            drift_trans_k = self.mission_plan.config['uncertainty_accumulation_rate_k']

            # if doing coverage, use the given drift model
            # to determine the drifting distance in meters
            # k is in meters per meter. last moved distance is meters, thus drift mag is in meters
            moved_dist = self.internal_auv.last_moved_distance
            drift_mag = moved_dist * drift_trans_k
            drift_x = drift_mag * np.cos(drift_trans_angle)
            drift_y = drift_mag * np.sin(drift_trans_angle)
        else:
            drift_x = 0
            drift_y = 0

        # and then finally update the real auv with the desired
        # motion from the internal auv and the drift that would cause
        self._real_auv.update(dt,
                              turn_direction = td,
                              turn_amount = ta,
                              drift_x = drift_x,
                              drift_y = drift_y,
                              drift_heading = 0.,
                              cover = cover)

        # compass is good
        self.internal_auv.set_heading(self._real_auv.heading)

        # finally update the pose graph with the internal auv
        self.pg.append_odom_pose(self.internal_auv.apose)

        # keep track of errors over the whole thing
        real_err = geom.euclid_distance(self._real_auv.pose[:2], self.internal_auv.pose[:2])
        self.real_errors.append(real_err)



    def communicate(self,
                    all_agents,
                    summarize_pg=True):

        recorded = False
        comm_dist = self.mission_plan.config['comm_range']

        for agent in all_agents:
            # skip self
            if agent.pg.pg_id == self.pg.pg_id:
                continue

            dist = geom.euclid_distance(self._real_auv.pose[:2], agent._real_auv.pose[:2])
            if dist <= comm_dist:
                self.pg.measure_tip_to_tip(self_real_pose = self._real_auv.pose,
                                           other_real_pose = agent._real_auv.pose,
                                           other_pg = agent.pg)

                num_vs, num_es = self.pg.fill_in_since_last_interaction(agent.pg, use_summary=summarize_pg)
                self.received_data['verts'].append((self.time, num_vs))
                self.received_data['edges'].append((self.time, num_es))

                # was not connected, just connected
                if not recorded:
                    self.connection_trace.append(True)
                    recorded = True

        # is not connected to anyone
        if not recorded:
            self.connection_trace.append(False)


        # if the connection status has changed, optimize the pose graph etc.
        if len(self.connection_trace) > 2:
            if self.connection_trace[-1] != self.connection_trace[-2]:
                success = self.pg.optimize(use_summary=summarize_pg, save_before=False)
                if success:
                    self.internal_auv.set_pose(self.pg.odom_tip_vertex.pose)
                    self.viz_optim_points.append(self.internal_auv.pose)
                    # also reset the dubins plan? so that we may re-plan next update?
                    self.current_dubins_points = []



    def distance_traveled_error(self):
        # from the GT auv, find distance traveled
        travel = self._real_auv.distance_traveled
        final_error = geom.euclid_distance(self._real_auv.apose, self.internal_auv.apose)
        error = final_error / travel
        self.log(f"Travel: {travel}, err:{final_error}, percent:{error*100}")
        return error


    def visualize(self, ax):
        real_trace = self._real_auv.pose_trace
        if len(real_trace) > 0:
            ax.plot(real_trace[:,0], real_trace[:,1], alpha=0.8, c=self.color)

        internal_trace = self.internal_auv.pose_trace
        if len(internal_trace) > 0:
            ax.plot(internal_trace[:,0], internal_trace[:,1], alpha=0.5, linestyle=':',  c=self.color)

        viz_lists = [
            self.viz_plan_points,
            self.viz_optim_points
        ]
        o = 1
        xoffs = [o,  o, -o, -o]
        yoffs = [o, -o, -o,  o]
        chars = ['p', 'o']
        for pts, xoff, yoff, char in zip(viz_lists, xoffs, yoffs, chars):
            if len(pts) > 0:
                for x,y,h in pts:
                    ax.text(x+xoff, y+yoff, char, color=self.color)
                    ax.scatter(x,y,c=self.color, marker='x', alpha=0.5)

        if len(self.viz_waited_points) > 0:
            p = np.array(self.viz_waited_points)
            ax.scatter(p[:,0], p[:,1], alpha=0.5, c=self.color, marker='o')







if __name__ == '__main__':
    import matplotlib.pyplot as plt
    plt.rcParams['pdf.fonttype'] = 42
    plt.ion()
    from pose_graph import PoseGraph, PGO_VertexIdStore
    from drift_model import DriftModel
    from tqdm import tqdm
    import sys

    try:
        seed = int(sys.argv[1])
        print(f'Given seed={seed}')
    except:
        import time
        seed = int(time.time())
        print(f'Time seed={seed}')

    np.random.seed(seed)
    dt = 0.05

    fig = plt.figure()
    ax = fig.add_subplot(111, aspect='equal')

    mplan = MissionPlan(
        plan_type = MissionPlan.PLAN_TYPE_DUBINS,
        # plan_type = MissionPlan.PLAN_TYPE_SIMPLE,
        num_agents = 2,
        swath = 50,
        rect_width = 200,
        rect_height = 200,
        speed = 1.5,
        uncertainty_accumulation_rate_k = 0.05,
        kept_uncertainty_ratio_after_loop = 0.8,
        turning_rad = 5,
        comm_range = 10
    )

    drift_model = DriftModel(
        num_spirals = 10,
        num_ripples = 0,
        area_xsize = mplan.config['rect_width'],
        area_ysize = mplan.config['rect_height'],
        scale_size = 1
    )

    pg_id_store = PGO_VertexIdStore()

    agents = []
    for i, timed_path in enumerate(mplan.timed_paths):
        auv = AUV(auv_id = i,
                  init_pos = timed_path.wps[0].pose[:2],
                  init_heading = np.rad2deg(timed_path.wps[0].pose[2]),
                  target_threshold = 2,
                  forward_speed = mplan.config['speed'])

        pg = PoseGraph(pg_id = i,
                       id_store = pg_id_store)

        agent = Agent(real_auv = auv,
                      pose_graph = pg,
                      mission_plan = mplan,
                      drift_model = drift_model)

        agents.append(agent)






    step = 0
    with tqdm(total = mplan.last_planned_time) as pbar:
        while True:
            step += 1
            for agent in agents:
                agent.update(dt = dt, all_agents = agents)

            for agent in agents:
                agent.communicate(all_agents = agents, summarize_pg = True)

            if mplan.is_complete:
                print("Plan completed")
                break

            if step*dt >= mplan.last_planned_time:
                print("Max planned time reached")
                break

            pbar.update(dt)




    drift_model.visualize(ax, 10, rect=mplan.bounding_rectangle, alpha=0.3)
    mplan.visualize(ax, alpha=0.5)

    for agent in agents:
        agent.visualize(ax)

    plt.figure()
    for agent in agents:
        plt.plot(agent.real_errors)

    ag = agents[0]
    auv = ag._real_auv





